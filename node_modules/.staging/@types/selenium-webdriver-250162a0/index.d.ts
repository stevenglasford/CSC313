// Type definitions for Selenium WebDriverJS 3.0
// Project: https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver, https://github.com/seleniumhq/selenium
// Definitions by: Bill Armstrong <https://github.com/BillArmstrong>,
//   Yuki Kokubun <https://github.com/Kuniwak>,
//   Craig Nishina <https://github.com/cnishina>,
//   Simon Gellis <https://github.com/SupernaviX>,
//   Ben Dixon <https://github.com/bendxn>,
//   Ziyu <https://github.com/oddui>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// TypeScript Version: 2.3

import * as chrome from './chrome';
import * as edge from './edge';
import * as firefox from './firefox';
import * as ie from './ie';
import * as opera from './opera';
import * as safari from './safari';

export namespace error {
  class IError extends Error {
    constructor(opt_error?: string);
  }

  /**
   * The base WebDriver error type. This error type is only used directly when a
   * more appropriate category is not defined for the offending error.
   */
  class WebDriverError extends IError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * An attempt was made to select an element that cannot be selected.
   */
  class ElementNotSelectableError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * An element command could not be completed because the element is not visible
   * on the page.
   */
  class ElementNotVisibleError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * The arguments passed to a command are either invalid or malformed.
   */
  class InvalidArgumentError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * An illegal attempt was made to set a cookie under a different domain than
   * the current page.
   */
  class InvalidCookieDomainError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * The coordinates provided to an interactions operation are invalid.
   */
  class InvalidElementCoordinatesError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * An element command could not be completed because the element is in an
   * invalid state, e.g. attempting to click an element that is no longer attached
   * to the document.
   */
  class InvalidElementStateError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * Argument was an invalid selector.
   */
  class InvalidSelectorError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * Occurs when a command is directed to a session that does not exist.
   */
  class NoSuchSessionError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * An error occurred while executing JavaScript supplied by the user.
   */
  class JavascriptError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * The target for mouse interaction is not in the browser’s viewport and cannot
   * be brought into that viewport.
   */
  class MoveTargetOutOfBoundsError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * An attempt was made to operate on a modal dialog when one was not open.
   */
  class NoSuchAlertError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * An element could not be located on the page using the given search
   * parameters.
   */
  class NoSuchElementError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * A request to switch to a frame could not be satisfied because the frame
   * could not be found.
   */
  class NoSuchFrameError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * A request to switch to a window could not be satisfied because the window
   * could not be found.
   */
  class NoSuchWindowError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * A script did not complete before its timeout expired.
   */
  class ScriptTimeoutError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * A new session could not be created.
   */
  class SessionNotCreatedError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * An element command failed because the referenced element is no longer
   * attached to the DOM.
   */
  class StaleElementReferenceError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * An operation did not completErrorCodee before its timeout expired.
   */
  class TimeoutError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * A request to set a cookie’s value could not be satisfied.
   */
  class UnableToSetCookieError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * A screen capture operation was not possible.
   */
  class UnableToCaptureScreenError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * A modal dialog was open, blocking this operation.
   */
  class UnexpectedAlertOpenError extends WebDriverError {
    /**
     * @param {string=} opt_error the error message, if any.
     * @param {string=} opt_text the text of the open dialog, if available.
     */
    constructor(opt_error?: string, opt_text?: string);

    /**
     * @return {(string|undefined)} The text displayed with the unhandled alert,
     *     if available.
     */
    getAlertText(): string;
  }

  /**
   * A command could not be executed because the remote end is not aware of it.
   */
  class UnknownCommandError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * The requested command matched a known URL but did not match an method for
   * that URL.
   */
  class UnknownMethodError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }

  /**
   * Reports an unsupport operation.
   */
  class UnsupportedOperationError extends WebDriverError {
    /** @param {string=} opt_error the error message, if any. */
    constructor(opt_error?: string);
  }
}

export namespace logging {
  /**
   * A hash describing log preferences.
   * @typedef {Object.<logging.Type, logging.LevelName>}
   */
  class Preferences {
    setLevel(type: string, level: Level | string | number): void;
    toJSON(): { [key: string]: string };
  }

  interface IType {
    /** Logs originating from the browser. */
    BROWSER: string;
    /** Logs from a WebDriver client. */
    CLIENT: string;
    /** Logs from a WebDriver implementation. */
    DRIVER: string;
    /** Logs related to performance. */
    PERFORMANCE: string;
    /** Logs from the remote server. */
    SERVER: string;
  }

  /**
   * Common log types.
   * @enum {string}
   */
  const Type: IType;

  /**
   * Defines a message level that may be used to control logging output.
   *
   * @final
   */
  class Level {
    name_: string;
    value_: number;
    /**
     * @param {string} name the level's name.
     * @param {number} level the level's numeric value.
     */
    constructor(name: string, level: number);

    /** @override */
    toString(): string;

    /** This logger's name. */
    name: string;

    /** The numeric log level. */
    value: number;

    /**
     * Indicates no log messages should be recorded.
     * @const
     */
    static OFF: Level;
    /**
     * Log messages with a level of `1000` or higher.
     * @const
     */
    static SEVERE: Level;
    /**
     * Log messages with a level of `900` or higher.
     * @const
     */
    static WARNING: Level;
    /**
     * Log messages with a level of `800` or higher.
     * @const
     */
    static INFO: Level;
    /**
     * Log messages with a level of `700` or higher.
     * @const
     */
    static DEBUG: Level;
    /**
     * Log messages with a level of `500` or higher.
     * @const
     */
    static FINE: Level;
    /**
     * Log messages with a level of `400` or higher.
     * @const
     */
    static FINER: Level;
    /**
     * Log messages with a level of `300` or higher.
     * @const
     */
    static FINEST: Level;
    /**
     * Indicates all log messages should be recorded.
     * @const
     */
    static ALL: Level;
  }

  /**
   * Converts a level name or value to a {@link logging.Level} value.
   * If the name/value is not recognized, {@link logging.Level.ALL}
   * will be returned.
   * @param {(number|string)} nameOrValue The log level name, or value, to
   *     convert .
   * @return {!logging.Level} The converted level.
   */
  function getLevel(nameOrValue: string | number): Level;

  interface IEntryJSON {
    level: string;
    message: string;
    timestamp: number;
    type: string;
  }

  /**
   * A single log entry.
   */
  class Entry {
    /**
     * @param {(!logging.Level|string)} level The entry level.
     * @param {string} message The log message.
     * @param {number=} opt_timestamp The time this entry was generated, in
     *     milliseconds since 0:00:00, January 1, 1970 UTC. If omitted, the
     *     current time will be used.
     * @param {string=} opt_type The log type, if known.
     * @constructor
     */
    constructor(level: Level | string | number, message: string, opt_timestamp?: number, opt_type?: string | IType);

    /** @type {!logging.Level} */
    level: Level;

    /** @type {string} */
    message: string;

    /** @type {number} */
    timestamp: number;

    /** @type {string} */
    type: string;

    /**
     * @return {{level: string, message: string, timestamp: number,
     *           type: string}} The JSON representation of this entry.
     */
    toJSON(): IEntryJSON;
  }

  /**
   * An object used to log debugging messages. Loggers use a hierarchical,
   * dot-separated naming scheme. For instance, 'foo' is considered the parent of
   * the 'foo.bar' and an ancestor of 'foo.bar.baz'.
   *
   * Each logger may be assigned a {@linkplain #setLevel log level}, which
   * controls which level of messages will be reported to the
   * {@linkplain #addHandler handlers} attached to this instance. If a log level
   * is not explicitly set on a logger, it will inherit its parent.
   *
   * This class should never be directly instantiated. Instead, users should
   * obtain logger references using the {@linkplain ./logging.getLogger()
   * getLogger()} function.
   *
   * @final
   */
  class Logger {
    /**
     * @param {string} name the name of this logger.
     * @param {Level=} opt_level the initial level for this logger.
     */
    constructor(name: string, opt_level?: Level);

    /** @private {string} */
    name_: string;
    /** @private {Level} */
    level_: Level;
    /** @private {Logger} */
    parent_: Logger;
    /** @private {Set<function(!Entry)>} */
    handlers_: any;

    /** @return {string} the name of this logger. */
    getName(): string;

    /**
     * @param {Level} level the new level for this logger, or `null` if the logger
     *     should inherit its level from its parent logger.
     */
    setLevel(level: Level): void;

    /** @return {Level} the log level for this logger. */
    getLevel(): Level;

    /**
     * @return {!Level} the effective level for this logger.
     */
    getEffectiveLevel(): Level;

    /**
     * @param {!Level} level the level to check.
     * @return {boolean} whether messages recorded at the given level are loggable
     *     by this instance.
     */
    isLoggable(level: Level): boolean;

    /**
     * Adds a handler to this logger. The handler will be invoked for each message
     * logged with this instance, or any of its descendants.
     *
     * @param {function(!Entry)} handler the handler to add.
     */
    addHandler(handler: any): void;

    /**
     * Removes a handler from this logger.
     *
     * @param {function(!Entry)} handler the handler to remove.
     * @return {boolean} whether a handler was successfully removed.
     */
    removeHandler(handler: any): void;

    /**
     * Logs a message at the given level. The message may be defined as a string
     * or as a function that will return the message. If a function is provided,
     * it will only be invoked if this logger's
     * {@linkplain #getEffectiveLevel() effective log level} includes the given
     * `level`.
     *
     * @param {!Level} level the level at which to log the message.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    log(level: Level, loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.SEVERE} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    severe(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.WARNING} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    warning(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.INFO} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    info(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.DEBUG} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    debug(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.FINE} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    fine(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.FINER} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    finer(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.FINEST} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    finest(loggable: string | Function): void;
  }

  /**
   * Maintains a collection of loggers.
   *
   * @final
   */
  class LogManager {
    /**
     * Retrieves a named logger, creating it in the process. This function will
     * implicitly create the requested logger, and any of its parents, if they
     * do not yet exist.
     *
     * @param {string} name the logger's name.
     * @return {!Logger} the requested logger.
     */
    getLogger(name?: string): Logger;

    /**
     * Creates a new logger.
     *
     * @param {string} name the logger's name.
     * @param {!Logger} parent the logger's parent.
     * @return {!Logger} the new logger.
     * @private
     */
    createLogger_(name: string, parent: Logger): Logger;
  }

  /**
   * Retrieves a named logger, creating it in the process. This function will
   * implicitly create the requested logger, and any of its parents, if they
   * do not yet exist.
   *
   * @param {string} name the logger's name.
   * @return {!Logger} the requested logger.
   */
  function getLogger(name?: string): Logger;

  /**
   * Adds the console handler to the given logger. The console handler will log
   * all messages using the JavaScript Console API.
   *
   * @param {Logger=} opt_logger The logger to add the handler to; defaults
   *     to the root logger.
   */
  function addConsoleHandler(opt_logger?: Logger): void;

  /**
   * Removes the console log handler from the given logger.
   *
   * @param {Logger=} opt_logger The logger to remove the handler from; defaults
   *     to the root logger.
   * @see exports.addConsoleHandler
   */
  function removeConsoleHandler(opt_logger?: Logger): void;
}

export namespace promise {
  // region Functions

  /**
   * Set `USE_PROMISE_MANAGER` to `false` to disable the promise manager.
   * This is useful, if you use async/await (see https://github.com/SeleniumHQ/selenium/issues/2969
   * and https://github.com/SeleniumHQ/selenium/issues/3037).
   */
  let USE_PROMISE_MANAGER: boolean;

  /**
   * Given an array of promises, will return a promise that will be fulfilled
   * with the fulfillment values of the input array's values. If any of the
   * input array's promises are rejected, the returned promise will be rejected
   * with the same reason.
   *
   * @param {!Array<(T|!ManagedPromise<T>)>} arr An array of
   *     promises to wait on.
   * @return {!ManagedPromise<!T[]>} A promise that is
   *     fulfilled with an array containing the fulfilled values of the
   *     input array, or rejected with the same reason as the first
   *     rejected value.
   * @template T
   */
  function all<T>(arr: Array<T | Promise<T>>): Promise<T[]>;

  /**
   * Invokes the appropriate callback function as soon as a promised
   * {@code value} is resolved. This function is similar to
   * {@link promise.when}, except it does not return a new promise.
   * @param {*} value The value to observe.
   * @param {Function} callback The function to call when the value is
   *     resolved successfully.
   * @param {Function=} opt_errback The function to call when the value is
   *     rejected.
   */
  function asap(value: any, callback: Function, opt_errback?: Function): void;

  /**
   * @return {!promise.ControlFlow} The currently active control flow.
   */
  function controlFlow(): ControlFlow;

  /**
   * Creates a new control flow. The provided callback will be invoked as the
   * first task within the new flow, with the flow as its sole argument. Returns
   * a promise that resolves to the callback result.
   * @param {function(!ControlFlow)} callback The entry point
   *     to the newly created flow.
   * @return {!ManagedPromise} A promise that resolves to the callback
   *     result.
   */
  function createFlow<R>(callback: (flow: ControlFlow) => R): Promise<R>;

  /**
   * Determines whether a {@code value} should be treated as a promise.
   * Any object whose 'then' property is a function will be considered a promise.
   *
   * @param {*} value The value to test.
   * @return {boolean} Whether the value is a promise.
   */
  function isPromise(value: any): boolean;

  /**
   * Tests is a function is a generator.
   * @param {!Function} fn The function to test.
   * @return {boolean} Whether the function is a generator.
   */
  function isGenerator(fn: Function): boolean;

  /**
   * Creates a promise that will be resolved at a set time in the future.
   * @param {number} ms The amount of time, in milliseconds, to wait before
   *     resolving the promise.
   * @return {!ManagedPromise} The promise.
   */
  function delayed(ms: number): Promise<void>;

  /**
   * Calls a function for each element in an array, and if the function returns
   * true adds the element to a new array.
   *
   * If the return value of the filter function is a promise, this function
   * will wait for it to be fulfilled before determining whether to insert the
   * element into the new array.
   *
   * If the filter function throws or returns a rejected promise, the promise
   * returned by this function will be rejected with the same reason. Only the
   * first failure will be reported; all subsequent errors will be silently
   * ignored.
   *
   * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The
   *     array to iterator over, or a promise that will resolve to said array.
   * @param {function(this: SELF, TYPE, number, !Array<TYPE>): (
   *             boolean|ManagedPromise<boolean>)} fn The function
   *     to call for each element in the array.
   * @param {SELF=} opt_self The object to be used as the value of 'this' within
   *     {@code fn}.
   * @template TYPE, SELF
   */
  function filter<T>(arr: T[] | Promise<T[]>, fn: (element: T, type: any, index: number, array: T[]) => any, opt_self?: any): Promise<T[]>;

  /**
   * Creates a new deferred object.
   * @return {!promise.Deferred} The new deferred object.
   */
  function defer<T>(): Deferred<T>;

  /**
   * Creates a promise that has been resolved with the given value.
   * @param {T=} opt_value The resolved value.
   * @return {!Promise<T>} The resolved promise.
   * @deprecated Use {@link Promise#resolve Promise.resolve(value)}.
   * @template T
   */
  function fulfilled<T>(opt_value?: T): Promise<T>;

  /**
   * Calls a function for each element in an array and inserts the result into a
   * new array, which is used as the fulfillment value of the promise returned
   * by this function.
   *
   * If the return value of the mapping function is a promise, this function
   * will wait for it to be fulfilled before inserting it into the new array.
   *
   * If the mapping function throws or returns a rejected promise, the
   * promise returned by this function will be rejected with the same reason.
   * Only the first failure will be reported; all subsequent errors will be
   * silently ignored.
   *
   * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The
   *     array to iterator over, or a promise that will resolve to said array.
   * @param {function(this: SELF, TYPE, number, !Array<TYPE>): ?} fn The
   *     function to call for each element in the array. This function should
   *     expect three arguments (the element, the index, and the array itself.
   * @param {SELF=} opt_self The object to be used as the value of 'this' within
   *     {@code fn}.
   * @template TYPE, SELF
   */
  function map<T>(arr: T[] | Promise<T[]>, fn: (self: any, type: any, index: number, array: T[]) => any, opt_self?: any): Promise<any[]>;

  /**
   * Creates a promise that has been rejected with the given reason.
   * @param {*=} opt_reason The rejection reason; may be any value, but is
   *     usually an Error or a string.
   * @return {!Promise<?>} The rejected promise.
   * @deprecated Use {@link Promise#reject Promise.Promise(reason)}.
   */
  function rejected<T>(opt_reason?: any): Promise<T>;

  /**
   * Wraps a function that expects a node-style callback as its final
   * argument. This callback expects two arguments: an error value (which will be
   * null if the call succeeded), and the success value as the second argument.
   * The callback will the resolve or reject the returned promise, based on its
   * arguments.
   * @param {!Function} fn The function to wrap.
   * @param {...?} var_args The arguments to apply to the function, excluding the
   *     final callback.
   * @return {!ManagedPromise} A promise that will be resolved with the
   *     result of the provided function's callback.
   */
  function checkedNodeCall<T>(fn: Function, ...var_args: any[]): Promise<T>;

  /**
   * Consumes a {@code GeneratorFunction}. Each time the generator yields a
   * promise, this function will wait for it to be fulfilled before feeding the
   * fulfilled value back into {@code next}. Likewise, if a yielded promise is
   * rejected, the rejection error will be passed to {@code throw}.
   *
   * __Example 1:__ the Fibonacci Sequence.
   *
   *     promise.consume(function* fibonacci() {
   *       var n1 = 1, n2 = 1;
   *       for (var i = 0; i < 4; ++i) {
   *         var tmp = yield n1 + n2;
   *         n1 = n2;
   *         n2 = tmp;
   *       }
   *       return n1 + n2;
   *     }).then(function(result) {
   *       console.log(result);  // 13
   *     });
   *
   * __Example 2:__ a generator that throws.
   *
   *     promise.consume(function* () {
   *       yield promise.delayed(250).then(function() {
   *         throw Error('boom');
   *       });
   *     }).catch(function(e) {
   *       console.log(e.toString());  // Error: boom
   *     });
   *
   * @param {!Function} generatorFn The generator function to execute.
   * @param {Object=} opt_self The object to use as 'this' when invoking the
   *     initial generator.
   * @param {...*} var_args Any arguments to pass to the initial generator.
   * @return {!ManagedPromise<?>} A promise that will resolve to the
   *     generator's final result.
   * @throws {TypeError} If the given function is not a generator.
   */
  function consume<T>(generatorFn: (...args: any[]) => T, opt_self?: any, ...var_args: any[]): Promise<T>;

  /**
   * Registers an observer on a promised {@code value}, returning a new promise
   * that will be resolved when the value is. If {@code value} is not a promise,
   * then the return promise will be immediately resolved.
   * @param {*} value The value to observe.
   * @param {Function=} opt_callback The function to call when the value is
   *     resolved successfully.
   * @param {Function=} opt_errback The function to call when the value is
   *     rejected.
   * @return {!ManagedPromise} A new promise.
   */
  function when<T>(value: T | Promise<T>, opt_callback?: (value: T) => any, opt_errback?: (error: any) => any): Promise<any>;

  /**
   * Returns a promise that will be resolved with the input value in a
   * fully-resolved state. If the value is an array, each element will be fully
   * resolved. Likewise, if the value is an object, all keys will be fully
   * resolved. In both cases, all nested arrays and objects will also be
   * fully resolved.  All fields are resolved in place; the returned promise will
   * resolve on {@code value} and not a copy.
   *
   * Warning: This function makes no checks against objects that contain
   * cyclical references:
   *
   *     var value = {};
   *     value['self'] = value;
   *     promise.fullyResolved(value);  // Stack overflow.
   *
   * @param {*} value The value to fully resolve.
   * @return {!ManagedPromise} A promise for a fully resolved version
   *     of the input value.
   */
  function fullyResolved<T>(value: any): Promise<T>;

  /**
   * Changes the default flow to use when no others are active.
   * @param {!ControlFlow} flow The new default flow.
   * @throws {Error} If the default flow is not currently active.
   */
  function setDefaultFlow(flow: ControlFlow): void;

  // endregion

  /**
   * Error used when the computation of a promise is cancelled.
   */
  class CancellationError extends Error {
    /**
     * @param {string=} opt_msg The cancellation message.
     */
    constructor(opt_msg?: string);
  }

  interface IThenable<T> extends PromiseLike<T> {
    /**
     * Registers listeners for when this instance is resolved.
     *
     * @param onfulfilled
     *     The function to call if this promise is successfully resolved. The function
     *     should expect a single argument: the promise's resolved value.
     * @param onrejected
     *     The function to call if this promise is rejected. The function should
     *     expect a single argument: the rejection reason.
     * @return A new promise which will be resolved with the result
     *     of the invoked callback.
     * @template R
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;

    /**
     * Registers a listener for when this promise is rejected. This is synonymous
     * with the {@code catch} clause in a synchronous API:
     *
     *     // Synchronous API:
     *     try {
     *       doSynchronousWork();
     *     } catch (ex) {
     *       console.error(ex);
     *     }
     *
     *     // Asynchronous promise API:
     *     doAsynchronousWork().catch(function(ex) {
     *       console.error(ex);
     *     });
     *
     * @param {function(*): (R|IThenable<R>)} errback The
     *     function to call if this promise is rejected. The function should
     *     expect a single argument: the rejection reason.
     * @return {!ManagedPromise<R>} A new promise which will be
     *     resolved with the result of the invoked callback.
     * @template R
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
  }

  /**
   * Thenable is a promise-like object with a {@code then} method which may be
   * used to schedule callbacks on a promised value.
   *
   * @interface
   * @template T
   */
  interface Thenable<T> extends IThenable<T> {}
  class Thenable<T> {
    /**
     * Registers a listener to invoke when this promise is resolved, regardless
     * of whether the promise's value was successfully computed. This function
     * is synonymous with the {@code finally} clause in a synchronous API:
     *
     *     // Synchronous API:
     *     try {
     *       doSynchronousWork();
     *     } finally {
     *       cleanUp();
     *     }
     *
     *     // Asynchronous promise API:
     *     doAsynchronousWork().finally(cleanUp);
     *
     * __Note:__ similar to the {@code finally} clause, if the registered
     * callback returns a rejected promise or throws an error, it will silently
     * replace the rejection error (if any) from this promise:
     *
     *     try {
     *       throw Error('one');
     *     } finally {
     *       throw Error('two');  // Hides Error: one
     *     }
     *
     *     promise.rejected(Error('one'))
     *         .finally(function() {
     *           throw Error('two');  // Hides Error: one
     *         });
     *
     * @param {function(): (R|IThenable<R>)} callback The function to call when
     *     this promise is resolved.
     * @return {!ManagedPromise<R>} A promise that will be fulfilled
     *     with the callback result.
     * @template R
     */
    finally<R>(callback: Function): Promise<R>;

    /**
     * Adds a property to a class prototype to allow runtime checks of whether
     * instances of that class implement the Thenable interface. This function
     * will also ensure the prototype's {@code then} function is exported from
     * compiled code.
     * @param {function(new: Thenable, ...?)} ctor The
     *     constructor whose prototype to modify.
     */
    static addImplementation(ctor: Function): void;

    /**
     * Checks if